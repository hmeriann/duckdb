# name: test/sql/copy/return_stats.test
# description: test RETURN_STATS parameter for COPY
# group: [copy]

require parquet

statement ok
SET preserve_insertion_order=false;

statement ok
SET threads=1

statement ok
CREATE VIEW integers AS SELECT range i FROM range(200000);

# single column
query IIIIII
COPY integers TO '__TEST_DIR__/test_copy_to_file.parquet' (RETURN_STATS);
----
<REGEX>:.*test_copy_to_file.parquet	200000	<REGEX>:\d+	<REGEX>:\d+	<REGEX>:\d+	{"i"={max=199999, min=0, null_count=0}}

# multi-column
statement ok
CREATE VIEW multi_column_test AS SELECT range i, range%10 j, case when range%2=0 then null else range end k FROM range(2500);

query IIIIII
COPY multi_column_test TO '__TEST_DIR__/multi_column_copy.parquet' (RETURN_STATS);
----
<REGEX>:.*multi_column_copy.parquet	2500	<REGEX>:\d+	<REGEX>:\d+	<REGEX>:\d+	{"i"={max=2499, min=0, null_count=0}, "j"={max=9, min=0, null_count=0}, "k"={max=2499, min=1, null_count=1250}}

# strings
statement ok
CREATE VIEW string_test AS SELECT concat('thisisalongstring_', range) s FROM range(2500);

query IIIIII
COPY string_test TO '__TEST_DIR__/string_test.parquet' (RETURN_STATS);
----
<REGEX>:.*string_test.parquet	2500	<REGEX>:\d+	<REGEX>:\d+	<REGEX>:\d+	{"s"={max=thisisalongstring_999, min=thisisalongstring_0, null_count=0}}

# timestamps/dates
statement ok
CREATE VIEW date_test AS
SELECT (TIMESTAMP '2000-01-01' + interval (range) day)::DATE dt,
       TIMESTAMP '2000-01-01 12:12:12.123456' + interval (range) day ts,
       (TIMESTAMP '2000-01-01 12:12:12' + interval (range) day)::TIMESTAMP_S ts_s,
       (TIMESTAMP '2000-01-01 12:12:12.123' + interval (range) day)::TIMESTAMP_MS ts_ms,
       concat((TIMESTAMP '2000-01-01 12:12:12.123456' + interval (range) day)::VARCHAR, '789')::TIMESTAMP_NS ts_ns,
       TIME '00:00:00' + interval (10 * range) second t
FROM range(2500);

query IIIIII
COPY date_test TO '__TEST_DIR__/date_test.parquet' (RETURN_STATS);
----
<REGEX>:.*date_test.parquet	2500	<REGEX>:\d+	<REGEX>:\d+	<REGEX>:\d+	{"dt"={max=2006-11-04, min=2000-01-01, null_count=0}, "t"={max=06:56:30, min=00:00:00, null_count=0}, "ts"={max=2006-11-04 12:12:12.123456, min=2000-01-01 12:12:12.123456, null_count=0}, "ts_ms"={max=2006-11-04 12:12:12.123, min=2000-01-01 12:12:12.123, null_count=0}, "ts_ns"={max=2006-11-04 12:12:12.123456789, min=2000-01-01 12:12:12.123456789, null_count=0}, "ts_s"={max=2006-11-04 12:12:12, min=2000-01-01 12:12:12, null_count=0}}

# empty table
statement ok
CREATE VIEW empty_test AS FROM range(2500) LIMIT 0;

query IIIIII
COPY empty_test TO '__TEST_DIR__/empty_test.parquet' (RETURN_STATS);
----
<REGEX>:.*empty_test.parquet	0	<REGEX>:\d+	<REGEX>:\d+	<REGEX>:\d+	{"range"={null_count=0}}

# blobs
statement ok
CREATE VIEW blob_test AS SELECT ''::BLOB AS bl UNION ALL SELECT '\x80\x00\x80'::BLOB

query IIIIII
COPY blob_test TO '__TEST_DIR__/blob_test.parquet' (RETURN_STATS);
----
<REGEX>:.*blob_test.parquet	2	<REGEX>:\d+	<REGEX>:\d+	<REGEX>:\d+	{"bl"={max=800080, min=, null_count=0}}

# decimal
statement ok
CREATE VIEW decimal_test AS
SELECT 25.3::DECIMAL(4,1) AS dec_i16,
       123456.789::DECIMAL(9,3) AS dec_i32,
       123456789123.456::DECIMAL(18,3) AS dec_i64
UNION ALL
SELECT 1.1::DECIMAL(4,1),
       2.123::DECIMAL(9,3),
       3.456::DECIMAL(18,3)

query IIIIII
COPY decimal_test TO '__TEST_DIR__/decimal_test.parquet' (RETURN_STATS);
----
<REGEX>:.*decimal_test.parquet	2	<REGEX>:\d+	<REGEX>:\d+	<REGEX>:\d+	{"dec_i16"={max=25.3, min=1.1, null_count=0}, "dec_i32"={max=123456.789, min=2.123, null_count=0}, "dec_i64"={max=123456789123.456, min=3.456, null_count=0}}

# struct
statement ok
CREATE VIEW struct_test AS SELECT case when i%10=0 then null else {'x': i, 'y': case when i%2=0 then 100 + i else null end} end struct_val FROM range(2500) t(i)

query IIIIII
COPY struct_test TO '__TEST_DIR__/struct_test.parquet' (RETURN_STATS);
----
<REGEX>:.*struct_test.parquet	2500	<REGEX>:\d+	<REGEX>:\d+	<REGEX>:\d+	{"struct_val"."x"={max=2499, min=1, null_count=250}, "struct_val"."y"={max=2598, min=102, null_count=1500}}

# list
statement ok
CREATE VIEW list_test AS SELECT [i] l1, case when i%10=0 then null else [case when i%2=0 then 100 + i else null end] end l2 FROM range(2500) t(i)

query IIIIII
COPY list_test TO '__TEST_DIR__/list_test.parquet' (RETURN_STATS);
----
<REGEX>:.*list_test.parquet	2500	<REGEX>:\d+	<REGEX>:\d+	<REGEX>:\d+	{"l1"."element"={max=2499, min=0}, "l2"."element"={max=2598, min=102}}

# nested struct
statement ok
CREATE VIEW nested_struct_test AS SELECT {'s1': {'x': i}, 's2': {'s3': {'y': i}, 'l': [i]}} n FROM range(2500) t(i)

query IIIIII
COPY nested_struct_test TO '__TEST_DIR__/nested_struct_test.parquet' (RETURN_STATS);
----
<REGEX>:.*nested_struct_test.parquet	2500	<REGEX>:\d+	<REGEX>:\d+	<REGEX>:\d+	{"n"."s1"."x"={max=2499, min=0, null_count=0}, "n"."s2"."l"."element"={max=2499, min=0}, "n"."s2"."s3"."y"={max=2499, min=0, null_count=0}}

# quoted/funky column names
statement ok
CREATE VIEW funky_names AS SELECT {'quoted ''"field name"': 42} """quoted col name"""

query IIIIII
COPY funky_names TO '__TEST_DIR__/funky_names.parquet' (RETURN_STATS);
----
<REGEX>:.*funky_names.parquet	1	<REGEX>:\d+	<REGEX>:\d+	<REGEX>:\d+	{"""quoted col name"""."quoted '""field name"""={max=42, min=42, null_count=0}}

# map
# array


# test all types
statement ok
COPY (FROM test_all_types()) TO '__TEST_DIR__/test_all_types.parquet' (RETURN_STATS);

# partition_by

# unsupported format (CSV)
statement error
COPY integers TO '__TEST_DIR__/test_copy_to_file.csv' (RETURN_STATS);
----
not supported
